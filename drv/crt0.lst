ca65 V2.19 - Git e5f4ca6
Main file   : crt0.s
Current file: crt0.s

000000r 1               ;=======================================================================
000000r 1               ;
000000r 1               ;		Start-up program
000000r 1               ;
000000r 1               ;						by A.Watanabe
000000r 1               ;
000000r 1               ;=======================================================================
000000r 1               
000000r 1               	.export		exit
000000r 1               
000000r 1               	.import		_main
000000r 1               	.import		NMI_main
000000r 1               	.import		IRQ_main
000000r 1               
000000r 1               	.import		ppudrv_init
000000r 1               	.import		Bank_Change_Prg
000000r 1               
000000r 1               	; Linker generated symbols
000000r 1               	.import		__STACK_START__,	__STACK_SIZE__
000000r 1               	.import		__RAM_START__,		__RAM_SIZE__
000000r 1               	.import		__SRAM_START__,		__SRAM_SIZE__
000000r 1               	.import		__ROM0_START__,		__ROM0_SIZE__
000000r 1               	.import		__STARTUP_LOAD__,	__STARTUP_RUN__,	__STARTUP_SIZE__
000000r 1               	.import		__CODE_LOAD__,		__CODE_RUN__,		__CODE_SIZE__
000000r 1               	.import		__RODATA_LOAD__,	__RODATA_RUN__,		__RODATA_SIZE__
000000r 1               	.import		__DATA_LOAD__,		__DATA_RUN__,		__DATA_SIZE__
000000r 1               
000000r 1               	.include	"drv.inc"
000000r 2               
000000r 2               	.setcpu		"6502"
000000r 2               
000000r 2               	.include	"nes.inc"
000000r 3               ;
000000r 3               ; NES definitions
000000r 3               ;
000000r 3               
000000r 3               .ifndef	__NES_INC__
000000r 3               
000000r 3               .define	__NES_INC__
000000r 3               
000000r 3               ;; PPU defines
000000r 3               PPU_CTRL1	= $2000
000000r 3               PPU_CTRL2	= $2001
000000r 3               PPU_STATUS	= $2002
000000r 3               PPU_SPR_ADDR	= $2003
000000r 3               PPU_SPR_IO  	= $2004
000000r 3               PPU_VRAM_ADDR1	= $2005
000000r 3               PPU_VRAM_ADDR2	= $2006
000000r 3               PPU_VRAM_IO	= $2007
000000r 3               
000000r 3               ;; APU defines
000000r 3               APU_PULSE1CTRL  = $4000         ; Pulse #1 Control Register (W)
000000r 3               APU_PULSE1RAMP  = $4001         ; Pulse #1 Ramp Control Register (W)
000000r 3               APU_PULSE1FTUNE = $4002         ; Pulse #1 Fine Tune (FT) Register (W)
000000r 3               APU_PULSE1CTUNE = $4003         ; Pulse #1 Coarse Tune (CT) Register (W)
000000r 3               APU_PULSE2CTRL  = $4004         ; Pulse #2 Control Register (W)
000000r 3               APU_PULSE2RAMP  = $4005         ; Pulse #2 Ramp Control Register (W)
000000r 3               APU_PULSE2FTUNE = $4006         ; Pulse #2 Fine Tune Register (W)
000000r 3               APU_PULSE2STUNE = $4007         ; Pulse #2 Coarse Tune Register (W)
000000r 3               APU_TRICTRL1    = $4008         ; Triangle Control Register #1 (W)
000000r 3               APU_TRICTRL2    = $4009         ; Triangle Control Register #2 (?)
000000r 3               APU_TRIFREQ1    = $400A         ; Triangle Frequency Register #1 (W)
000000r 3               APU_TRIFREQ2    = $400B         ; Triangle Frequency Register #2 (W)
000000r 3               APU_NOISECTRL   = $400C         ; Noise Control Register #1 (W)
000000r 3               ;;APU_ = $400D  ; Unused (???)
000000r 3               APU_NOISEFREQ1  = $400E         ; Noise Frequency Register #1 (W)
000000r 3               APU_NOISEFREQ2  = $400F         ; Noise Frequency Register #2 (W)
000000r 3               APU_MODCTRL     = $4010         ; Delta Modulation Control Register (W)
000000r 3               APU_MODDA       = $4011         ; Delta Modulation D/A Register (W)
000000r 3               APU_MODADDR     = $4012         ; Delta Modulation Address Register (W)
000000r 3               APU_MODLEN      = $4013         ; Delta Modulation Data Length Register (W)
000000r 3               APU_SPR_DMA    	= $4014         ; Sprite DMA Register (W)
000000r 3               APU_CHANCTRL   	= $4015         ; Sound/Vertical Clock Signal Register (R)
000000r 3               APU_PAD1       	= $4016         ; Joypad #1 (RW)
000000r 3               APU_PAD2	= $4017         ; Joypad #2/SOFTCLK (RW)
000000r 3               
000000r 3               .endif
000000r 3               
000000r 2               	.include	"macro.inc"
000000r 3               
000000r 3               
000000r 3               ;=======================================================================
000000r 3               ;	Macros
000000r 3               ;-----------------------------------------------------------------------
000000r 3               
000000r 3               .MACPACK generic
000000r 4               
000000r 4               ; add - Add without carry
000000r 4               .macro  add     Arg1, Arg2
000000r 4                       clc
000000r 4                       .if .paramcount = 2
000000r 4                               adc     Arg1, Arg2
000000r 4                       .else
000000r 4                               adc     Arg1
000000r 4                       .endif
000000r 4               .endmacro
000000r 4               
000000r 4               ; sub - subtract without borrow
000000r 4               .macro  sub     Arg1, Arg2
000000r 4                       sec
000000r 4                       .if .paramcount = 2
000000r 4                               sbc     Arg1, Arg2
000000r 4                       .else
000000r 4                               sbc     Arg1
000000r 4                       .endif
000000r 4               .endmacro
000000r 4               
000000r 4               ; bge - jump if unsigned greater or equal
000000r 4               .macro  bge     Arg
000000r 4                       bcs     Arg
000000r 4               .endmacro
000000r 4               
000000r 4               ; blt - Jump if unsigned less
000000r 4               .macro  blt     Arg
000000r 4                       bcc     Arg
000000r 4               .endmacro
000000r 4               
000000r 4               ; bgt - jump if unsigned greater
000000r 4               .macro  bgt     Arg
000000r 4                       .local  L
000000r 4                       beq     L
000000r 4                       bcs     Arg
000000r 4               L:
000000r 4               .endmacro
000000r 4               
000000r 4               ; ble - jump if unsigned less or equal
000000r 4               .macro  ble     Arg
000000r 4                       beq     Arg
000000r 4                       bcc     Arg
000000r 4               .endmacro
000000r 4               
000000r 4               ; bnz - jump if not zero
000000r 4               .macro  bnz     Arg
000000r 4                       bne     Arg
000000r 4               .endmacro
000000r 4               
000000r 4               ; bze - jump if zero
000000r 4               .macro  bze     Arg
000000r 4                       beq     Arg
000000r 4               .endmacro
000000r 4               
000000r 4               
000000r 3               .MACPACK longbranch
000000r 4               .macro  jeq     Target
000000r 4                       .if     .match(Target, 0)
000000r 4                       bne     *+5
000000r 4                       jmp     Target
000000r 4                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 4                               beq     Target
000000r 4                       .else
000000r 4                               bne     *+5
000000r 4                               jmp     Target
000000r 4                       .endif
000000r 4               .endmacro
000000r 4               .macro  jne     Target
000000r 4                       .if     .match(Target, 0)
000000r 4                               beq     *+5
000000r 4                               jmp     Target
000000r 4                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 4                               bne     Target
000000r 4                       .else
000000r 4                               beq     *+5
000000r 4                               jmp     Target
000000r 4                       .endif
000000r 4               .endmacro
000000r 4               .macro  jmi     Target
000000r 4                       .if     .match(Target, 0)
000000r 4                               bpl     *+5
000000r 4                               jmp     Target
000000r 4                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 4                               bmi     Target
000000r 4                       .else
000000r 4                               bpl     *+5
000000r 4                               jmp     Target
000000r 4                       .endif
000000r 4               .endmacro
000000r 4               .macro  jpl     Target
000000r 4                       .if     .match(Target, 0)
000000r 4                               bmi     *+5
000000r 4                               jmp     Target
000000r 4                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 4                               bpl     Target
000000r 4                       .else
000000r 4                               bmi     *+5
000000r 4                               jmp     Target
000000r 4                       .endif
000000r 4               .endmacro
000000r 4               .macro  jcs     Target
000000r 4                       .if     .match(Target, 0)
000000r 4                               bcc     *+5
000000r 4                               jmp     Target
000000r 4                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 4                               bcs     Target
000000r 4                       .else
000000r 4                               bcc     *+5
000000r 4                               jmp     Target
000000r 4                       .endif
000000r 4               .endmacro
000000r 4               .macro  jcc     Target
000000r 4                       .if     .match(Target, 0)
000000r 4                               bcs     *+5
000000r 4                               jmp     Target
000000r 4                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 4                               bcc     Target
000000r 4                       .else
000000r 4                               bcs     *+5
000000r 4                               jmp     Target
000000r 4                       .endif
000000r 4               .endmacro
000000r 4               .macro  jvs     Target
000000r 4                       .if     .match(Target, 0)
000000r 4                               bvc     *+5
000000r 4                               jmp     Target
000000r 4                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 4                               bvs     Target
000000r 4                       .else
000000r 4                               bvc     *+5
000000r 4                               jmp     Target
000000r 4                       .endif
000000r 4               .endmacro
000000r 4               .macro  jvc     Target
000000r 4                       .if     .match(Target, 0)
000000r 4                               bvs     *+5
000000r 4                               jmp     Target
000000r 4                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 4                               bvc     Target
000000r 4                       .else
000000r 4                               bvs     *+5
000000r 4                               jmp     Target
000000r 4                       .endif
000000r 4               .endmacro
000000r 4               
000000r 3               
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	ax <= arg(mem16/imm16)
000000r 3               ;---------------------------------------
000000r 3               .macro	LDAX	arg
000000r 3               	.if (.match (.left (1, {arg}), #))
000000r 3               		; immediate mode
000000r 3               		lda     #<(.right (.tcount ({arg})-1, {arg}))
000000r 3               		ldx     #>(.right (.tcount ({arg})-1, {arg}))
000000r 3               	.else
000000r 3               		; assume absolute or zero page
000000r 3               		lda     arg
000000r 3               		ldx     1+(arg)
000000r 3               	.endif
000000r 3               .endmacro
000000r 3               
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	arg(mem16) <= ax
000000r 3               ;---------------------------------------
000000r 3               .macro	STAX	arg
000000r 3               		; assume absolute or zero page
000000r 3               		sta     arg
000000r 3               		stx     1+(arg)
000000r 3               .endmacro
000000r 3               
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	ax <= ax + arg(mem16/imm16)
000000r 3               ;---------------------------------------
000000r 3               .macro	ADDW	arg
000000r 3               	clc
000000r 3               	.if (.match (.left (1, {arg}), #))
000000r 3               		; immediate mode
000000r 3               		adc     #<(.right (.tcount ({arg})-1, {arg}))
000000r 3               		pha
000000r 3               		txa
000000r 3               		adc     #>(.right (.tcount ({arg})-1, {arg}))
000000r 3               		tax
000000r 3               		pla
000000r 3               	.else
000000r 3               		; assume absolute or zero page
000000r 3               		adc     arg
000000r 3               		pha
000000r 3               		txa
000000r 3               		adc     1+(arg)
000000r 3               		tax
000000r 3               		pla
000000r 3               	.endif
000000r 3               .endmacro
000000r 3               
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	ax <= ax - arg(mem16/imm16)
000000r 3               ;---------------------------------------
000000r 3               .macro	SUBW	arg
000000r 3               	sec
000000r 3               	.if (.match (.left (1, {arg}), #))
000000r 3               		; immediate mode
000000r 3               		sbc     #<(.right (.tcount ({arg})-1, {arg}))
000000r 3               		pha
000000r 3               		txa
000000r 3               		sbc     #>(.right (.tcount ({arg})-1, {arg}))
000000r 3               		tax
000000r 3               		pla
000000r 3               	.else
000000r 3               		; assume absolute or zero page
000000r 3               		sbc     arg
000000r 3               		pha
000000r 3               		txa
000000r 3               		sbc     1+(arg)
000000r 3               		tax
000000r 3               		pla
000000r 3               	.endif
000000r 3               .endmacro
000000r 3               
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	arg(ax/mem16)++
000000r 3               ;---------------------------------------
000000r 3               .macro	INCW	arg
000000r 3               	.local	Skip
000000r 3               
000000r 3               	.if (.blank(arg)) .or (.xmatch ({arg}, ax))
000000r 3               		add	#1
000000r 3               		bne	Skip
000000r 3               		inx
000000r 3               	.else
000000r 3               		inc	arg
000000r 3               		bne	Skip
000000r 3               		inc	1+(arg)
000000r 3               	.endif
000000r 3               Skip:
000000r 3               .endmacro
000000r 3               
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	arg(ax/mem16)--
000000r 3               ;---------------------------------------
000000r 3               .macro	DECW	arg
000000r 3               	.local	Skip
000000r 3               	.if (.blank(arg)) .or (.match ({arg}, ax))
000000r 3               		sub	#1
000000r 3               		bcc	Skip
000000r 3               		dex
000000r 3               	.else
000000r 3               		pha
000000r 3               		lda	arg
000000r 3               		sub	#1
000000r 3               		sta	arg
000000r 3               		bcc	Skip
000000r 3               		dec	1+(arg)
000000r 3               		pla
000000r 3               	.endif
000000r 3               Skip:
000000r 3               .endmacro
000000r 3               
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	arg(a/mem8) <<= c
000000r 3               ;---------------------------------------
000000r 3               .macro	SHL	arg, c
000000r 3               	.repeat	c
000000r 3               		asl	arg
000000r 3               	.endrepeat
000000r 3               .endmacro
000000r 3               
000000r 3               .macro	shl	arg, c
000000r 3               	.repeat	c
000000r 3               		asl	arg
000000r 3               	.endrepeat
000000r 3               .endmacro
000000r 3               
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	arg(a/mem8) >>= c
000000r 3               ;---------------------------------------
000000r 3               .macro	SHR	arg, c
000000r 3               	.repeat	c
000000r 3               		lsr	arg
000000r 3               	.endrepeat
000000r 3               .endmacro
000000r 3               
000000r 3               .macro	shr	arg, c
000000r 3               	.repeat	c
000000r 3               		lsr	arg
000000r 3               	.endrepeat
000000r 3               .endmacro
000000r 3               
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	a >>= c	（算術シフト）	※アキュムレータ限定
000000r 3               ;---------------------------------------
000000r 3               .macro	SAR	arg, c
000000r 3               
000000r 3               	.if (.match ({arg}, a))
000000r 3               
000000r 3               		.repeat	c
000000r 3               			cmp	#$80
000000r 3               			ror	a
000000r 3               		.endrepeat
000000r 3               	.else
000000r 3               		pha
000000r 3               		lda	arg
000000r 3               		.repeat	c
000000r 3               			cmp	#$80
000000r 3               			ror	a
000000r 3               		.endrepeat
000000r 3               		sta	arg
000000r 3               		pla
000000r 3               	.endif
000000r 3               
000000r 3               .endmacro
000000r 3               
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	arg(mem16) <<= c
000000r 3               ;---------------------------------------
000000r 3               .macro	SHLW	arg, c
000000r 3               	.repeat	c
000000r 3               		asl	arg
000000r 3               		rol	1+(arg)
000000r 3               	.endrepeat
000000r 3               .endmacro
000000r 3               
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	arg(mem16) >>= c
000000r 3               ;---------------------------------------
000000r 3               .macro	SHRW	arg, c
000000r 3               	.repeat	c
000000r 3               		lsr	1+(arg)
000000r 3               		ror	arg
000000r 3               	.endrepeat
000000r 3               .endmacro
000000r 3               
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	arg(mem16) >>= c	（算術シフト）
000000r 3               ;---------------------------------------
000000r 3               .macro	SARW	arg, c
000000r 3               	pha
000000r 3               	lda	1+(arg)
000000r 3               	.repeat	c
000000r 3               		cmp	#$80
000000r 3               		ror	a
000000r 3               		ror	arg
000000r 3               	.endrepeat
000000r 3               	sta	1+(arg)
000000r 3               	pla
000000r 3               .endmacro
000000r 3               
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	ＢＧアドレス計算
000000r 3               ;---------------------------------------
000000r 3               ;	ptx	X 座標
000000r 3               ;	pty	Y 座標
000000r 3               ;	scn	スクリーン番号
000000r 3               ;---------------------------------------
000000r 3               .define	ADDR_BG(ptx,pty,scn)	$2000 + (ptx) + ((pty)*32) + ((scn)*$400)
000000r 3               
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	スプライトアドレス計算
000000r 3               ;---------------------------------------
000000r 3               ;	number	スプライト番号（0～63）
000000r 3               ;	member	アクセスするメンバー
000000r 3               ;		　ptx	Ｘ座標
000000r 3               ;		　pty	Ｙ座標
000000r 3               ;		　num	キャラクター
000000r 3               ;		　att	属性（パレットや反転など）
000000r 3               ;---------------------------------------
000000r 3               .define	ADDR_SPR(number,member)	_ppu_sprite_buff + ((number)*4) + SPR_ONE::member
000000r 3               
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	VBLANK 待ち
000000r 3               ;---------------------------------------
000000r 3               .macro	WAIT_VBLANK
000000r 3               	.local	Skip
000000r 3               Skip:	lda	PPU_STATUS
000000r 3               	bpl	Skip
000000r 3               .endmacro
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	NMI 割り込み待ち
000000r 3               ;---------------------------------------
000000r 3               .macro	WAIT_NMI
000000r 3               	.local	Skip
000000r 3               	lda	__cc
000000r 3               Skip:	cmp	__cc
000000r 3               	beq	Skip
000000r 3               .endmacro
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	ジャンプ
000000r 3               ;---------------------------------------
000000r 3               .macro	JMP_AX
000000r 3               	STAX	_JMP_Address
000000r 3               	jmp	(_JMP_Address)
000000r 3               .endmacro
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	コール
000000r 3               ;---------------------------------------
000000r 3               .macro	JSR_AX
000000r 3               	jsr	jsr_ax
000000r 3               .endmacro
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	バンク間コール
000000r 3               ;---------------------------------------
000000r 3               .macro	FARJSR	bank, adr
000000r 3               	LDAX	adr
000000r 3               	ldy	bank
000000r 3               	jsr	jsr_axy
000000r 3               .endmacro
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	画面表示
000000r 3               ;	※垂直同期を待つこと！！
000000r 3               ;---------------------------------------
000000r 3               .macro	DISP_SET
000000r 3               	sta	PPU_CTRL1
000000r 3               	sta	__Flag_2000
000000r 3               .endmacro
000000r 3               
000000r 3               .macro	DISP_SET1
000000r 3               	sta	PPU_CTRL1
000000r 3               	sta	__Flag_2000
000000r 3               .endmacro
000000r 3               
000000r 3               .macro	DISP_SET2
000000r 3               	sta	PPU_CTRL2
000000r 3               	sta	__Flag_2001
000000r 3               .endmacro
000000r 3               ;---------------------------------------
000000r 3               ;	画面表示
000000r 3               ;---------------------------------------
000000r 3               .macro	DISP_ON
000000r 3               	WAIT_VBLANK			;垂直同期まで待つ
000000r 3               	lda	#sysdef::PPU_Ctrl1_set	;割り込みは開始する。
000000r 3               	sta	PPU_CTRL1
000000r 3               	sta	__Flag_2000
000000r 3               	lda	#sysdef::PPU_Ctrl2_set	;MMC3 IRQの初期化のために、
000000r 3               	sta	__Flag_2001		;BG, Spr共に表示をonにする。
000000r 3               	sta	PPU_CTRL2		;
000000r 3               .endmacro
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	画面を消します。
000000r 3               ;	（消す前の状態は、維持）
000000r 3               ;---------------------------------------
000000r 3               .macro	DISP_OFF
000000r 3               	lda	#%00000000
000000r 3               	sta	PPU_CTRL1
000000r 3               	sta	PPU_CTRL2
000000r 3               	WAIT_VBLANK			;画面が消えるまで待つ
000000r 3               .endmacro
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	画面を元に戻します。
000000r 3               ;	（消す前の状態に、復帰）
000000r 3               ;---------------------------------------
000000r 3               .macro	DISP_RET
000000r 3               	WAIT_VBLANK			;垂直同期まで待つ
000000r 3               	lda	__Flag_2000
000000r 3               	sta	PPU_CTRL1
000000r 3               	lda	__Flag_2001
000000r 3               	sta	PPU_CTRL2
000000r 3               .endmacro
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	キー取得
000000r 3               ;---------------------------------------
000000r 3               ;●現在押されているキー
000000r 3               .macro	GET_PAD0
000000r 3               	lda	__PAD0
000000r 3               .endmacro
000000r 3               
000000r 3               .macro	GET_PAD1
000000r 3               	lda	__PAD1
000000r 3               .endmacro
000000r 3               
000000r 3               ;●離されたキー
000000r 3               .macro	GET_PAD0_REMOVE
000000r 3               	lda	__PAD0_REL
000000r 3               .endmacro
000000r 3               
000000r 3               .macro	GET_PAD1_REMOVE
000000r 3               	lda	__PAD1_REL
000000r 3               .endmacro
000000r 3               
000000r 3               ;●押されたキー
000000r 3               .macro	GET_PAD0_PRESS
000000r 3               	lda	__PAD0_TRG
000000r 3               .endmacro
000000r 3               
000000r 3               .macro	GET_PAD1_PRESS
000000r 3               	lda	__PAD1_TRG
000000r 3               .endmacro
000000r 3               
000000r 3               
000000r 2               
000000r 2               
000000r 2               MAX_TRACK 	=	16
000000r 2               LAST_TRACK	=	MAX_TRACK - 1
000000r 2               MAX_LOOP	=	3
000000r 2               
000000r 2               FRAG_KEYON			=	%00000001
000000r 2               FRAG_KEYON_CLR		=	%11111110
000000r 2               FRAG_KEYOFF			=	%00000010
000000r 2               FRAG_KEYOFF_CLR		=	%11111101
000000r 2               FRAG_LOAD			=	%00000100
000000r 2               FRAG_LOAD_CLR		=	%11111011
000000r 2               FRAG_KEYON_DIS		=	%00001000
000000r 2               FRAG_KEYON_DIS_CLR	=	%11110111
000000r 2               FRAG_SIL			=	%00010000
000000r 2               FRAG_SIL_CLR		=	%11101111
000000r 2               FRAG_WRITE_DIS		=	%00100000
000000r 2               FRAG_WRITE_DIS_CLR	=	%11011111
000000r 2               FRAG_END			=	%10000000
000000r 2               FRAG_END_CLR		=	%01111111
000000r 2               
000000r 2               FRAG_VENV			=	%00000001
000000r 2               FRAG_VENV_CLR		=	%11111110
000000r 2               FRAG_FENV			=	%00000010
000000r 2               FRAG_FENV_CLR		=	%11111101
000000r 2               FRAG_NENV			=	%00000100
000000r 2               FRAG_NENV_CLR		=	%11111011
000000r 2               FRAG_TENV			=	%00001000
000000r 2               FRAG_TENV_CLR		=	%11110111
000000r 2               FRAG_SSWP			=	%00010000
000000r 2               FRAG_SSWP_CLR		=	%11101111
000000r 2               FRAG_ENV_DIS		=	%10000000
000000r 2               FRAG_ENV_DIS_CLR	=	%01111111
000000r 2               
000000r 2               
000000r 2               ;---------------------------------------
000000r 2               ;	システムプログラム中の定数を定義します。
000000r 2               ;---------------------------------------
000000r 2               
000000r 2               .scope	sysdef
000000r 2               
000000r 2               ;PPU
000000r 2               PPU_Ctrl1_set		= PPU_CTRL1_VBLANK | PPU_CTRL1_SPTBL
000000r 2               PPU_Ctrl2_set		= PPU_CTRL2_SPDISP | PPU_CTRL2_BGDISP | PPU_CTRL2_SPCLIP | PPU_CTRL2_BGCLIP
000000r 2               
000000r 2               .endscope
000000r 2               
000000r 2               
000000r 2               
000000r 2               
000000r 2               ;---------------------------------------
000000r 2               ;	ＩＯ
000000r 2               ;---------------------------------------
000000r 2               ; $2000 PPU Control Register 0
000000r 2               PPU_CTRL1_VBLANK	= $80
000000r 2               PPU_CTRL1_SLAVE		= $40
000000r 2               PPU_CTRL1_SP16		= $20
000000r 2               PPU_CTRL1_BGTBL		= $10
000000r 2               PPU_CTRL1_SPTBL		= $08
000000r 2               PPU_CTRL1_INC32		= $04
000000r 2               PPU_CTRL1_NAMETBL	= $03
000000r 2               
000000r 2               ; $2001 PPU Control Register 1
000000r 2               PPU_CTRL2_BGCOLOR	= $E0
000000r 2               PPU_CTRL2_SPDISP	= $10
000000r 2               PPU_CTRL2_BGDISP	= $08
000000r 2               PPU_CTRL2_SPCLIP	= $04
000000r 2               PPU_CTRL2_BGCLIP	= $02
000000r 2               PPU_CTRL2_COLORMODE	= $01
000000r 2               
000000r 1               
000000r 1               
000000r 1               ; ------------------------------------------------------------------------
000000r 1               ; Place the startup code in a special segment.
000000r 1               
000000r 1               .segment	"STARTUP"
000000r 1               
000000r 1  44 52 46 4D  .byte	"DRFM  "
000004r 1  20 20        
000006r 1               
000006r 1               start:
000006r 1               
000006r 1               ; setup the CPU and System and Sound Driver nsd.lib
000006r 1               
000006r 1  78           	sei
000007r 1  D8           	cld
000008r 1               
000008r 1  A9 00 8D 00  	DISP_OFF
00000Cr 1  20 8D 01 20  
000010r 1  AD 02 20 10  
000014r 1  FB           
000015r 1               
000015r 1               ;===============================
000015r 1               ;	メモリ初期化
000015r 1               ;===============================
000015r 1               Clear_Memory:
000015r 1               
000015r 1  A9 00        	lda	#0
000017r 1  A2 rr        	ldx	#<(__STACK_START__ + __STACK_SIZE__ - 1)
000019r 1  9A           	txs
00001Ar 1  AA           	tax
00001Br 1               @L0:
00001Br 1  95 00        	sta	$0000,x
00001Dr 1               ;	sta	$0100,x
00001Dr 1               ;	sta	$0200,x
00001Dr 1               ;	sta	$0300,x
00001Dr 1               ;	sta	$0400,x
00001Dr 1               ;	sta	$0500,x
00001Dr 1               ;	sta	$0600,x
00001Dr 1               ;	sta	$0700,x
00001Dr 1               
00001Dr 1  E8           	inx
00001Er 1  D0 FB        	bne	@L0
000020r 1               
000020r 1               ;===============================
000020r 1               ;	サウンド初期化
000020r 1               ;===============================
000020r 1               Sound_Init:
000020r 1               
000020r 1  A9 40        	LDA	#$40
000022r 1  8D 17 40     	STA	APU_PAD2
000025r 1               
000025r 1               	; Call initialize sound driver
000025r 1               	;jsr	_nsd_init
000025r 1               
000025r 1               ;===============================
000025r 1               ;	画面初期化
000025r 1               ;===============================
000025r 1               ;Disp_Init:
000025r 1               
000025r 1               	; Call initialize PPU
000025r 1  20 rr rr     	jsr	_ppu_init
000028r 1               
000028r 1               ;===============================
000028r 1               ;	メインルーチン呼出し
000028r 1               ;===============================
000028r 1               ; Push arguments and call main()
000028r 1               
000028r 1  20 rr rr     	jsr	_main
00002Br 1               
00002Br 1               ; Call module destructors. This is also the _exit entry.
00002Br 1               
00002Br 1               exit:
00002Br 1               
00002Br 1               ; Reset the NES
00002Br 1               
00002Br 1  4C rr rr     	jmp	start
00002Er 1               
00002Er 1               ; ------------------------------------------------------------------------
00002Er 1               ; Init PPU
00002Er 1               ; ------------------------------------------------------------------------
00002Er 1               .proc	_ppu_init
00002Er 1               
00002Er 1               	;---------------
00002Er 1               	; PPU Control
00002Er 1  A9 A8        	lda	#%10101000		;V-Blank NMI: enable
000030r 1  8D 00 20     	sta	PPU_CTRL1
000033r 1               
000033r 1  A9 1E        	lda	#%00011110
000035r 1  8D 01 20     	sta	PPU_CTRL2
000038r 1               
000038r 1               	;---------------
000038r 1               	; Wait for vblank
000038r 1  AD 02 20     @wait:	lda	PPU_STATUS
00003Br 1  10 FB        	bpl	@wait
00003Dr 1               
00003Dr 1               	;---------------
00003Dr 1               	; reset scrolling
00003Dr 1  A9 00        	lda	#0
00003Fr 1  8D 05 20     	sta	PPU_VRAM_ADDR1
000042r 1  8D 05 20     	sta	PPU_VRAM_ADDR1
000045r 1               
000045r 1               	;---------------
000045r 1               	; Make all sprites invisible
000045r 1  A9 00        	lda	#$00
000047r 1  A0 F0        	ldy	#$f0
000049r 1  8D 03 20     	sta	PPU_SPR_ADDR
00004Cr 1  A2 40        	ldx	#$40
00004Er 1  8C 04 20     @loop:	sty	PPU_SPR_IO
000051r 1  8D 04 20     	sta	PPU_SPR_IO
000054r 1  8D 04 20     	sta	PPU_SPR_IO
000057r 1  8C 04 20     	sty	PPU_SPR_IO
00005Ar 1  CA           	dex
00005Br 1  D0 F1        	bne	@loop
00005Dr 1               
00005Dr 1  60           	rts
00005Er 1               
00005Er 1               .endproc
00005Er 1               
00005Er 1               ; ------------------------------------------------------------------------
00005Er 1               ; hardware vectors
00005Er 1               ; ------------------------------------------------------------------------
00005Er 1               
00005Er 1               .segment "VECTORS"
000000r 1               
000000r 1  rr rr        	.word	NMI_main	; $fffa vblank nmi
000002r 1  rr rr        	.word	start		; $fffc reset
000004r 1  rr rr        	.word	IRQ_main	; $fffe irq / brk
000004r 1               
