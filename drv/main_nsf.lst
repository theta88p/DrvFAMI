ca65 V2.19 - Git e5f4ca6
Main file   : main_nsf.s
Current file: main_nsf.s

000000r 1               
000000r 1               	.export		_main
000000r 1               	.export		_init
000000r 1               	.export		_play
000000r 1               
000000r 1               	.import		drv_init
000000r 1               	.import		drv_sndreq
000000r 1               	.import		drv_main
000000r 1               	.import		set_dpcm
000000r 1               	.import		_DPCMinfo
000000r 1               	.import		_BGM0
000000r 1               
000000r 1               	.include	"drv.inc"
000000r 2               
000000r 2               	.setcpu		"6502"
000000r 2               
000000r 2               	.include	"nes.inc"
000000r 3               ;
000000r 3               ; NES definitions
000000r 3               ;
000000r 3               
000000r 3               .ifndef	__NES_INC__
000000r 3               
000000r 3               .define	__NES_INC__
000000r 3               
000000r 3               ;; PPU defines
000000r 3               PPU_CTRL1	= $2000
000000r 3               PPU_CTRL2	= $2001
000000r 3               PPU_STATUS	= $2002
000000r 3               PPU_SPR_ADDR	= $2003
000000r 3               PPU_SPR_IO  	= $2004
000000r 3               PPU_VRAM_ADDR1	= $2005
000000r 3               PPU_VRAM_ADDR2	= $2006
000000r 3               PPU_VRAM_IO	= $2007
000000r 3               
000000r 3               ;; APU defines
000000r 3               APU_PULSE1CTRL  = $4000         ; Pulse #1 Control Register (W)
000000r 3               APU_PULSE1RAMP  = $4001         ; Pulse #1 Ramp Control Register (W)
000000r 3               APU_PULSE1FTUNE = $4002         ; Pulse #1 Fine Tune (FT) Register (W)
000000r 3               APU_PULSE1CTUNE = $4003         ; Pulse #1 Coarse Tune (CT) Register (W)
000000r 3               APU_PULSE2CTRL  = $4004         ; Pulse #2 Control Register (W)
000000r 3               APU_PULSE2RAMP  = $4005         ; Pulse #2 Ramp Control Register (W)
000000r 3               APU_PULSE2FTUNE = $4006         ; Pulse #2 Fine Tune Register (W)
000000r 3               APU_PULSE2STUNE = $4007         ; Pulse #2 Coarse Tune Register (W)
000000r 3               APU_TRICTRL1    = $4008         ; Triangle Control Register #1 (W)
000000r 3               APU_TRICTRL2    = $4009         ; Triangle Control Register #2 (?)
000000r 3               APU_TRIFREQ1    = $400A         ; Triangle Frequency Register #1 (W)
000000r 3               APU_TRIFREQ2    = $400B         ; Triangle Frequency Register #2 (W)
000000r 3               APU_NOISECTRL   = $400C         ; Noise Control Register #1 (W)
000000r 3               ;;APU_ = $400D  ; Unused (???)
000000r 3               APU_NOISEFREQ1  = $400E         ; Noise Frequency Register #1 (W)
000000r 3               APU_NOISEFREQ2  = $400F         ; Noise Frequency Register #2 (W)
000000r 3               APU_MODCTRL     = $4010         ; Delta Modulation Control Register (W)
000000r 3               APU_MODDA       = $4011         ; Delta Modulation D/A Register (W)
000000r 3               APU_MODADDR     = $4012         ; Delta Modulation Address Register (W)
000000r 3               APU_MODLEN      = $4013         ; Delta Modulation Data Length Register (W)
000000r 3               APU_SPR_DMA    	= $4014         ; Sprite DMA Register (W)
000000r 3               APU_CHANCTRL   	= $4015         ; Sound/Vertical Clock Signal Register (R)
000000r 3               APU_PAD1       	= $4016         ; Joypad #1 (RW)
000000r 3               APU_PAD2	= $4017         ; Joypad #2/SOFTCLK (RW)
000000r 3               
000000r 3               .endif
000000r 3               
000000r 2               	.include	"macro.inc"
000000r 3               
000000r 3               
000000r 3               ;=======================================================================
000000r 3               ;	Macros
000000r 3               ;-----------------------------------------------------------------------
000000r 3               
000000r 3               .MACPACK generic
000000r 4               
000000r 4               ; add - Add without carry
000000r 4               .macro  add     Arg1, Arg2
000000r 4                       clc
000000r 4                       .if .paramcount = 2
000000r 4                               adc     Arg1, Arg2
000000r 4                       .else
000000r 4                               adc     Arg1
000000r 4                       .endif
000000r 4               .endmacro
000000r 4               
000000r 4               ; sub - subtract without borrow
000000r 4               .macro  sub     Arg1, Arg2
000000r 4                       sec
000000r 4                       .if .paramcount = 2
000000r 4                               sbc     Arg1, Arg2
000000r 4                       .else
000000r 4                               sbc     Arg1
000000r 4                       .endif
000000r 4               .endmacro
000000r 4               
000000r 4               ; bge - jump if unsigned greater or equal
000000r 4               .macro  bge     Arg
000000r 4                       bcs     Arg
000000r 4               .endmacro
000000r 4               
000000r 4               ; blt - Jump if unsigned less
000000r 4               .macro  blt     Arg
000000r 4                       bcc     Arg
000000r 4               .endmacro
000000r 4               
000000r 4               ; bgt - jump if unsigned greater
000000r 4               .macro  bgt     Arg
000000r 4                       .local  L
000000r 4                       beq     L
000000r 4                       bcs     Arg
000000r 4               L:
000000r 4               .endmacro
000000r 4               
000000r 4               ; ble - jump if unsigned less or equal
000000r 4               .macro  ble     Arg
000000r 4                       beq     Arg
000000r 4                       bcc     Arg
000000r 4               .endmacro
000000r 4               
000000r 4               ; bnz - jump if not zero
000000r 4               .macro  bnz     Arg
000000r 4                       bne     Arg
000000r 4               .endmacro
000000r 4               
000000r 4               ; bze - jump if zero
000000r 4               .macro  bze     Arg
000000r 4                       beq     Arg
000000r 4               .endmacro
000000r 4               
000000r 4               
000000r 3               .MACPACK longbranch
000000r 4               .macro  jeq     Target
000000r 4                       .if     .match(Target, 0)
000000r 4                       bne     *+5
000000r 4                       jmp     Target
000000r 4                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 4                               beq     Target
000000r 4                       .else
000000r 4                               bne     *+5
000000r 4                               jmp     Target
000000r 4                       .endif
000000r 4               .endmacro
000000r 4               .macro  jne     Target
000000r 4                       .if     .match(Target, 0)
000000r 4                               beq     *+5
000000r 4                               jmp     Target
000000r 4                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 4                               bne     Target
000000r 4                       .else
000000r 4                               beq     *+5
000000r 4                               jmp     Target
000000r 4                       .endif
000000r 4               .endmacro
000000r 4               .macro  jmi     Target
000000r 4                       .if     .match(Target, 0)
000000r 4                               bpl     *+5
000000r 4                               jmp     Target
000000r 4                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 4                               bmi     Target
000000r 4                       .else
000000r 4                               bpl     *+5
000000r 4                               jmp     Target
000000r 4                       .endif
000000r 4               .endmacro
000000r 4               .macro  jpl     Target
000000r 4                       .if     .match(Target, 0)
000000r 4                               bmi     *+5
000000r 4                               jmp     Target
000000r 4                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 4                               bpl     Target
000000r 4                       .else
000000r 4                               bmi     *+5
000000r 4                               jmp     Target
000000r 4                       .endif
000000r 4               .endmacro
000000r 4               .macro  jcs     Target
000000r 4                       .if     .match(Target, 0)
000000r 4                               bcc     *+5
000000r 4                               jmp     Target
000000r 4                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 4                               bcs     Target
000000r 4                       .else
000000r 4                               bcc     *+5
000000r 4                               jmp     Target
000000r 4                       .endif
000000r 4               .endmacro
000000r 4               .macro  jcc     Target
000000r 4                       .if     .match(Target, 0)
000000r 4                               bcs     *+5
000000r 4                               jmp     Target
000000r 4                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 4                               bcc     Target
000000r 4                       .else
000000r 4                               bcs     *+5
000000r 4                               jmp     Target
000000r 4                       .endif
000000r 4               .endmacro
000000r 4               .macro  jvs     Target
000000r 4                       .if     .match(Target, 0)
000000r 4                               bvc     *+5
000000r 4                               jmp     Target
000000r 4                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 4                               bvs     Target
000000r 4                       .else
000000r 4                               bvc     *+5
000000r 4                               jmp     Target
000000r 4                       .endif
000000r 4               .endmacro
000000r 4               .macro  jvc     Target
000000r 4                       .if     .match(Target, 0)
000000r 4                               bvs     *+5
000000r 4                               jmp     Target
000000r 4                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 4                               bvc     Target
000000r 4                       .else
000000r 4                               bvs     *+5
000000r 4                               jmp     Target
000000r 4                       .endif
000000r 4               .endmacro
000000r 4               
000000r 3               
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	ax <= arg(mem16/imm16)
000000r 3               ;---------------------------------------
000000r 3               .macro	LDAX	arg
000000r 3               	.if (.match (.left (1, {arg}), #))
000000r 3               		; immediate mode
000000r 3               		lda     #<(.right (.tcount ({arg})-1, {arg}))
000000r 3               		ldx     #>(.right (.tcount ({arg})-1, {arg}))
000000r 3               	.else
000000r 3               		; assume absolute or zero page
000000r 3               		lda     arg
000000r 3               		ldx     1+(arg)
000000r 3               	.endif
000000r 3               .endmacro
000000r 3               
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	arg(mem16) <= ax
000000r 3               ;---------------------------------------
000000r 3               .macro	STAX	arg
000000r 3               		; assume absolute or zero page
000000r 3               		sta     arg
000000r 3               		stx     1+(arg)
000000r 3               .endmacro
000000r 3               
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	ax <= ax + arg(mem16/imm16)
000000r 3               ;---------------------------------------
000000r 3               .macro	ADDW	arg
000000r 3               	clc
000000r 3               	.if (.match (.left (1, {arg}), #))
000000r 3               		; immediate mode
000000r 3               		adc     #<(.right (.tcount ({arg})-1, {arg}))
000000r 3               		pha
000000r 3               		txa
000000r 3               		adc     #>(.right (.tcount ({arg})-1, {arg}))
000000r 3               		tax
000000r 3               		pla
000000r 3               	.else
000000r 3               		; assume absolute or zero page
000000r 3               		adc     arg
000000r 3               		pha
000000r 3               		txa
000000r 3               		adc     1+(arg)
000000r 3               		tax
000000r 3               		pla
000000r 3               	.endif
000000r 3               .endmacro
000000r 3               
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	ax <= ax - arg(mem16/imm16)
000000r 3               ;---------------------------------------
000000r 3               .macro	SUBW	arg
000000r 3               	sec
000000r 3               	.if (.match (.left (1, {arg}), #))
000000r 3               		; immediate mode
000000r 3               		sbc     #<(.right (.tcount ({arg})-1, {arg}))
000000r 3               		pha
000000r 3               		txa
000000r 3               		sbc     #>(.right (.tcount ({arg})-1, {arg}))
000000r 3               		tax
000000r 3               		pla
000000r 3               	.else
000000r 3               		; assume absolute or zero page
000000r 3               		sbc     arg
000000r 3               		pha
000000r 3               		txa
000000r 3               		sbc     1+(arg)
000000r 3               		tax
000000r 3               		pla
000000r 3               	.endif
000000r 3               .endmacro
000000r 3               
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	arg(ax/mem16)++
000000r 3               ;---------------------------------------
000000r 3               .macro	INCW	arg
000000r 3               	.local	Skip
000000r 3               
000000r 3               	.if (.blank(arg)) .or (.xmatch ({arg}, ax))
000000r 3               		add	#1
000000r 3               		bne	Skip
000000r 3               		inx
000000r 3               	.else
000000r 3               		inc	arg
000000r 3               		bne	Skip
000000r 3               		inc	1+(arg)
000000r 3               	.endif
000000r 3               Skip:
000000r 3               .endmacro
000000r 3               
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	arg(ax/mem16)--
000000r 3               ;---------------------------------------
000000r 3               .macro	DECW	arg
000000r 3               	.local	Skip
000000r 3               	.if (.blank(arg)) .or (.match ({arg}, ax))
000000r 3               		sub	#1
000000r 3               		bcc	Skip
000000r 3               		dex
000000r 3               	.else
000000r 3               		pha
000000r 3               		lda	arg
000000r 3               		sub	#1
000000r 3               		sta	arg
000000r 3               		bcc	Skip
000000r 3               		dec	1+(arg)
000000r 3               		pla
000000r 3               	.endif
000000r 3               Skip:
000000r 3               .endmacro
000000r 3               
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	arg(a/mem8) <<= c
000000r 3               ;---------------------------------------
000000r 3               .macro	SHL	arg, c
000000r 3               	.repeat	c
000000r 3               		asl	arg
000000r 3               	.endrepeat
000000r 3               .endmacro
000000r 3               
000000r 3               .macro	shl	arg, c
000000r 3               	.repeat	c
000000r 3               		asl	arg
000000r 3               	.endrepeat
000000r 3               .endmacro
000000r 3               
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	arg(a/mem8) >>= c
000000r 3               ;---------------------------------------
000000r 3               .macro	SHR	arg, c
000000r 3               	.repeat	c
000000r 3               		lsr	arg
000000r 3               	.endrepeat
000000r 3               .endmacro
000000r 3               
000000r 3               .macro	shr	arg, c
000000r 3               	.repeat	c
000000r 3               		lsr	arg
000000r 3               	.endrepeat
000000r 3               .endmacro
000000r 3               
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	a >>= c	（算術シフト）	※アキュムレータ限定
000000r 3               ;---------------------------------------
000000r 3               .macro	SAR	arg, c
000000r 3               
000000r 3               	.if (.match ({arg}, a))
000000r 3               
000000r 3               		.repeat	c
000000r 3               			cmp	#$80
000000r 3               			ror	a
000000r 3               		.endrepeat
000000r 3               	.else
000000r 3               		pha
000000r 3               		lda	arg
000000r 3               		.repeat	c
000000r 3               			cmp	#$80
000000r 3               			ror	a
000000r 3               		.endrepeat
000000r 3               		sta	arg
000000r 3               		pla
000000r 3               	.endif
000000r 3               
000000r 3               .endmacro
000000r 3               
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	arg(mem16) <<= c
000000r 3               ;---------------------------------------
000000r 3               .macro	SHLW	arg, c
000000r 3               	.repeat	c
000000r 3               		asl	arg
000000r 3               		rol	1+(arg)
000000r 3               	.endrepeat
000000r 3               .endmacro
000000r 3               
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	arg(mem16) >>= c
000000r 3               ;---------------------------------------
000000r 3               .macro	SHRW	arg, c
000000r 3               	.repeat	c
000000r 3               		lsr	1+(arg)
000000r 3               		ror	arg
000000r 3               	.endrepeat
000000r 3               .endmacro
000000r 3               
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	arg(mem16) >>= c	（算術シフト）
000000r 3               ;---------------------------------------
000000r 3               .macro	SARW	arg, c
000000r 3               	pha
000000r 3               	lda	1+(arg)
000000r 3               	.repeat	c
000000r 3               		cmp	#$80
000000r 3               		ror	a
000000r 3               		ror	arg
000000r 3               	.endrepeat
000000r 3               	sta	1+(arg)
000000r 3               	pla
000000r 3               .endmacro
000000r 3               
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	ＢＧアドレス計算
000000r 3               ;---------------------------------------
000000r 3               ;	ptx	X 座標
000000r 3               ;	pty	Y 座標
000000r 3               ;	scn	スクリーン番号
000000r 3               ;---------------------------------------
000000r 3               .define	ADDR_BG(ptx,pty,scn)	$2000 + (ptx) + ((pty)*32) + ((scn)*$400)
000000r 3               
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	スプライトアドレス計算
000000r 3               ;---------------------------------------
000000r 3               ;	number	スプライト番号（0～63）
000000r 3               ;	member	アクセスするメンバー
000000r 3               ;		　ptx	Ｘ座標
000000r 3               ;		　pty	Ｙ座標
000000r 3               ;		　num	キャラクター
000000r 3               ;		　att	属性（パレットや反転など）
000000r 3               ;---------------------------------------
000000r 3               .define	ADDR_SPR(number,member)	_ppu_sprite_buff + ((number)*4) + SPR_ONE::member
000000r 3               
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	VBLANK 待ち
000000r 3               ;---------------------------------------
000000r 3               .macro	WAIT_VBLANK
000000r 3               	.local	Skip
000000r 3               Skip:	lda	PPU_STATUS
000000r 3               	bpl	Skip
000000r 3               .endmacro
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	NMI 割り込み待ち
000000r 3               ;---------------------------------------
000000r 3               .macro	WAIT_NMI
000000r 3               	.local	Skip
000000r 3               	lda	__cc
000000r 3               Skip:	cmp	__cc
000000r 3               	beq	Skip
000000r 3               .endmacro
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	ジャンプ
000000r 3               ;---------------------------------------
000000r 3               .macro	JMP_AX
000000r 3               	STAX	_JMP_Address
000000r 3               	jmp	(_JMP_Address)
000000r 3               .endmacro
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	コール
000000r 3               ;---------------------------------------
000000r 3               .macro	JSR_AX
000000r 3               	jsr	jsr_ax
000000r 3               .endmacro
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	バンク間コール
000000r 3               ;---------------------------------------
000000r 3               .macro	FARJSR	bank, adr
000000r 3               	LDAX	adr
000000r 3               	ldy	bank
000000r 3               	jsr	jsr_axy
000000r 3               .endmacro
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	画面表示
000000r 3               ;	※垂直同期を待つこと！！
000000r 3               ;---------------------------------------
000000r 3               .macro	DISP_SET
000000r 3               	sta	PPU_CTRL1
000000r 3               	sta	__Flag_2000
000000r 3               .endmacro
000000r 3               
000000r 3               .macro	DISP_SET1
000000r 3               	sta	PPU_CTRL1
000000r 3               	sta	__Flag_2000
000000r 3               .endmacro
000000r 3               
000000r 3               .macro	DISP_SET2
000000r 3               	sta	PPU_CTRL2
000000r 3               	sta	__Flag_2001
000000r 3               .endmacro
000000r 3               ;---------------------------------------
000000r 3               ;	画面表示
000000r 3               ;---------------------------------------
000000r 3               .macro	DISP_ON
000000r 3               	WAIT_VBLANK			;垂直同期まで待つ
000000r 3               	lda	#sysdef::PPU_Ctrl1_set	;割り込みは開始する。
000000r 3               	sta	PPU_CTRL1
000000r 3               	sta	__Flag_2000
000000r 3               	lda	#sysdef::PPU_Ctrl2_set	;MMC3 IRQの初期化のために、
000000r 3               	sta	__Flag_2001		;BG, Spr共に表示をonにする。
000000r 3               	sta	PPU_CTRL2		;
000000r 3               .endmacro
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	画面を消します。
000000r 3               ;	（消す前の状態は、維持）
000000r 3               ;---------------------------------------
000000r 3               .macro	DISP_OFF
000000r 3               	lda	#%00000000
000000r 3               	sta	PPU_CTRL1
000000r 3               	sta	PPU_CTRL2
000000r 3               	WAIT_VBLANK			;画面が消えるまで待つ
000000r 3               .endmacro
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	画面を元に戻します。
000000r 3               ;	（消す前の状態に、復帰）
000000r 3               ;---------------------------------------
000000r 3               .macro	DISP_RET
000000r 3               	WAIT_VBLANK			;垂直同期まで待つ
000000r 3               	lda	__Flag_2000
000000r 3               	sta	PPU_CTRL1
000000r 3               	lda	__Flag_2001
000000r 3               	sta	PPU_CTRL2
000000r 3               .endmacro
000000r 3               
000000r 3               ;---------------------------------------
000000r 3               ;	キー取得
000000r 3               ;---------------------------------------
000000r 3               ;●現在押されているキー
000000r 3               .macro	GET_PAD0
000000r 3               	lda	__PAD0
000000r 3               .endmacro
000000r 3               
000000r 3               .macro	GET_PAD1
000000r 3               	lda	__PAD1
000000r 3               .endmacro
000000r 3               
000000r 3               ;●離されたキー
000000r 3               .macro	GET_PAD0_REMOVE
000000r 3               	lda	__PAD0_REL
000000r 3               .endmacro
000000r 3               
000000r 3               .macro	GET_PAD1_REMOVE
000000r 3               	lda	__PAD1_REL
000000r 3               .endmacro
000000r 3               
000000r 3               ;●押されたキー
000000r 3               .macro	GET_PAD0_PRESS
000000r 3               	lda	__PAD0_TRG
000000r 3               .endmacro
000000r 3               
000000r 3               .macro	GET_PAD1_PRESS
000000r 3               	lda	__PAD1_TRG
000000r 3               .endmacro
000000r 3               
000000r 3               
000000r 2               
000000r 2               
000000r 2               MAX_TRACK 	=	16
000000r 2               LAST_TRACK	=	MAX_TRACK - 1
000000r 2               MAX_LOOP	=	3
000000r 2               
000000r 2               FRAG_KEYON			=	%00000001
000000r 2               FRAG_KEYON_CLR		=	%11111110
000000r 2               FRAG_KEYOFF			=	%00000010
000000r 2               FRAG_KEYOFF_CLR		=	%11111101
000000r 2               FRAG_LOAD			=	%00000100
000000r 2               FRAG_LOAD_CLR		=	%11111011
000000r 2               FRAG_KEYON_DIS		=	%00001000
000000r 2               FRAG_KEYON_DIS_CLR	=	%11110111
000000r 2               FRAG_SIL			=	%00010000
000000r 2               FRAG_SIL_CLR		=	%11101111
000000r 2               FRAG_WRITE_DIS		=	%00100000
000000r 2               FRAG_WRITE_DIS_CLR	=	%11011111
000000r 2               FRAG_END			=	%10000000
000000r 2               FRAG_END_CLR		=	%01111111
000000r 2               
000000r 2               FRAG_VENV			=	%00000001
000000r 2               FRAG_VENV_CLR		=	%11111110
000000r 2               FRAG_FENV			=	%00000010
000000r 2               FRAG_FENV_CLR		=	%11111101
000000r 2               FRAG_NENV			=	%00000100
000000r 2               FRAG_NENV_CLR		=	%11111011
000000r 2               FRAG_TENV			=	%00001000
000000r 2               FRAG_TENV_CLR		=	%11110111
000000r 2               FRAG_SSWP			=	%00010000
000000r 2               FRAG_SSWP_CLR		=	%11101111
000000r 2               FRAG_ENV_DIS		=	%10000000
000000r 2               FRAG_ENV_DIS_CLR	=	%01111111
000000r 2               
000000r 2               
000000r 2               ;---------------------------------------
000000r 2               ;	システムプログラム中の定数を定義します。
000000r 2               ;---------------------------------------
000000r 2               
000000r 2               .scope	sysdef
000000r 2               
000000r 2               ;PPU
000000r 2               PPU_Ctrl1_set		= PPU_CTRL1_VBLANK | PPU_CTRL1_SPTBL
000000r 2               PPU_Ctrl2_set		= PPU_CTRL2_SPDISP | PPU_CTRL2_BGDISP | PPU_CTRL2_SPCLIP | PPU_CTRL2_BGCLIP
000000r 2               
000000r 2               .endscope
000000r 2               
000000r 2               
000000r 2               
000000r 2               
000000r 2               ;---------------------------------------
000000r 2               ;	ＩＯ
000000r 2               ;---------------------------------------
000000r 2               ; $2000 PPU Control Register 0
000000r 2               PPU_CTRL1_VBLANK	= $80
000000r 2               PPU_CTRL1_SLAVE		= $40
000000r 2               PPU_CTRL1_SP16		= $20
000000r 2               PPU_CTRL1_BGTBL		= $10
000000r 2               PPU_CTRL1_SPTBL		= $08
000000r 2               PPU_CTRL1_INC32		= $04
000000r 2               PPU_CTRL1_NAMETBL	= $03
000000r 2               
000000r 2               ; $2001 PPU Control Register 1
000000r 2               PPU_CTRL2_BGCOLOR	= $E0
000000r 2               PPU_CTRL2_SPDISP	= $10
000000r 2               PPU_CTRL2_BGDISP	= $08
000000r 2               PPU_CTRL2_SPCLIP	= $04
000000r 2               PPU_CTRL2_BGCLIP	= $02
000000r 2               PPU_CTRL2_COLORMODE	= $01
000000r 2               
000000r 1               
000000r 1               
000000r 1               ; ------------------------------------------------------------------------
000000r 1               ; play
000000r 1               ; ------------------------------------------------------------------------
000000r 1               
000000r 1               .rodata
000000r 1               
000000r 1               ;Address of D-PCM information
000000r 1  rr rr        dpcm_info:	.addr	_DPCMinfo
000002r 1               
000002r 1               ;Address of BGM Sequence
000002r 1  rr rr        bgm_00:		.addr	_BGM0
000004r 1               
000004r 1               ; ------------------------------------------------------------------------
000004r 1               ; main
000004r 1               ; ------------------------------------------------------------------------
000004r 1               .code
000000r 1               
000000r 1               .proc	_main
000000r 1               
000000r 1  20 rr rr     	jsr _init
000003r 1               
000003r 1               ;Wait_Next_Flame:
000003r 1               ;	jmp	Wait_Next_Flame
000003r 1  60           	rts
000004r 1               
000004r 1               .endproc
000004r 1               
000004r 1               .proc _init
000004r 1  48           	pha
000005r 1  20 rr rr     	jsr drv_init
000008r 1               
000008r 1  AD rr rr     	lda	dpcm_info
00000Br 1  AE rr rr     	ldx	dpcm_info + 1
00000Er 1  20 rr rr     	jsr	set_dpcm
000011r 1  68           	pla
000012r 1  A8           	tay
000013r 1  AD rr rr     	lda	bgm_00
000016r 1  AE rr rr     	ldx	bgm_00 + 1
000019r 1  20 rr rr     	jsr	drv_sndreq
00001Cr 1               .endproc
00001Cr 1               
00001Cr 1               .proc	_play
00001Cr 1  4C rr rr     	jmp	drv_main
00001Fr 1               .endproc
00001Fr 1               
